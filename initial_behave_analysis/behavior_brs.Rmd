---
title: " prelim behavioral analyses - dictator task"
author: "Brooke Staveland"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,  # don't print the code chunk
  warning = FALSE,  # don't print warnings
  message = FALSE,  # don't print messages
  fig.width = 12,  # set default width of figures
  fig.height = 6,  # set default height of figures
  fig.align = "center",  # always align figure in center
  fig.pos = "H",  # always plot figure at the exact location of the code chunk
  cache = TRUE)  # cache results

## libraries ##
library(tidyverse)
library(ggplot2)
library(magrittr)
library(ggthemr)
library(grid)
library(gtable)
library(gridExtra)
library(wesanderson)
library(ggsci)
library(zoo)
library(kableExtra)
library(lme4)
library(RColorBrewer)
library(lme4)

## hand written functions ##

source('~/Projects/nice_r_functions/ggpaired_pretty.R')

```


These analyses started for two main reasons: 1) Deborah and I wanted to run some common sense checks to make sure patients were attending to the task, and to identify any one who may not be and 2) we wanted to see how the sets presented in this task correspond to the task in _Andreoni & Miller 2002_ and _Saez et al 2015_.

I think I figured out the task structure, but would love it if you could confirm. However, in checking the patient data we realized there was a very strong bias to the left, which I will dig into below. I am worried about how we will be able to interpret at least four of the subject's data, and we might want to take up Bob's suggestion that we collect new subjects. Or maybe the left side bias was indeed purposefully built into the task, and I am just missing the rationale?

_Update on December 16th 2019_

I was wrong about the trial structure presented on Dec 6 2019. Instead we find that the best representation is to use the raw choices which were presented to subjects either 3 or 6 times. The bottom of this analysis now includes a chunk that creates a new counterbalanced version of the task. The analyses showing the original Left/Right inabalnce were preserved.

```{r load-data}

filenames <- dir("../dg_behave_formatted/","behav.csv")
DATA <- NULL

for (i in 1:length(filenames)) {
  temp <- cbind(SID=substr(filenames[i],1,6),read.csv(filenames[i], header=TRUE))
  temp$RT <- as.numeric(as.character(temp$RT))
  DATA <- rbind(DATA,temp)
}

# use abs(ineq)
DATA$ineq <- abs(DATA$ineq)

# # get variable option payoff
# DATA$self.var.payoff <- DATA$self.payoff + DATA$self.foregone - 10
# DATA$other.var.payoff <- DATA$other.payoff + DATA$other.foregone - 10
# DATA$diff.var.payoff <- abs(DATA$self.var.payoff - DATA$other.var.payoff)
# 
# # get variable option ineq
# DATA$var.ineq.disadvant <- as.numeric(DATA$other.var.payoff>DATA$self.var.payoff) * (DATA$other.var.payoff-DATA$self.var.payoff)
# DATA$var.ineq.advant <- as.numeric(DATA$other.var.payoff<DATA$self.var.payoff) * (DATA$other.var.payoff-DATA$self.var.payoff)

# trial type

trialTypes <- read.csv('../../../trial_type.csv', header = T)

respDataRaw <- merge.data.frame(DATA, trialTypes, by.x = "round", by.y = "X")

sub_round_index <- unique(respDataRaw$SID[which(respDataRaw$round > 200)])

## plotting helpers ##
ggthemr("solarized")
getPalette = colorRampPalette(brewer.pal(9, "Set1"))

```


```{r prep-dfs}

respData <- respDataRaw %>%
  mutate(side_chosen_numeric = side.chosen) %>%
  mutate(side_chosen = if_else(side.chosen == 76, "Left", if_else(side.chosen == 82, "Right", "Other"))) %>%
  mutate(ethical = if_else(side_chosen == better_other, "Selfless", "Selfish")) %>%
  mutate(option_one = if_else(self.payoff == 10 & other.payoff == 10, "10-10", "Other")) %>%
  mutate(trial_type_full = paste0(L.self, ":", L.other, ":",  R.self, ":", R.other))

probEqual8 <- respData %>%
  filter(SID %in% sub_round_index) %>%
  filter(self_diff == 0) %>%
  group_by(SID, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(p_left = Left/24) %>%
  mutate(p_right = Right/24) %>%
  select(-`vars(side_chosen)`)  %>%
  mutate(prob_type = "Equal")
  
probEqual4 <- respData %>%
  filter(!(SID %in% sub_round_index)) %>%
  filter(self_diff == 0) %>%
  group_by(SID, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(p_left = Left/21) %>%
  mutate(p_right = Right/21) %>%
  select(-`vars(side_chosen)`)   %>%
  mutate(prob_type = "Equal")

probEqual <- rbind(probEqual4, probEqual8)

probLeft8 <- respData %>%
  filter(SID %in% sub_round_index) %>%
  filter(L.self > R.self) %>%
  group_by(SID, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(p_left = Left/147) %>%
  mutate(p_right = Right/147) %>%
  select(-`vars(side_chosen)`)  %>%
  mutate(prob_type = "Left")
  
probLeft4 <- respData %>%
  filter(!(SID %in% sub_round_index)) %>%
  filter(L.self > R.self) %>%
  group_by(SID, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(p_left = Left/130) %>%
  mutate(p_right = Right/130) %>%
  select(-`vars(side_chosen)`) %>%
  mutate(prob_type = "Left")
  
probLeft <- rbind(probLeft4, probLeft8)


probRight8 <- respData %>%
  filter(SID %in% sub_round_index) %>%
  filter(L.self < R.self) %>%
  group_by(SID, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(p_left = Left/57) %>%
  mutate(p_right = Right/57) %>%
  select(-`vars(side_chosen)`) %>%
  mutate(prob_type = "Right")
  
probRight4 <- respData %>%
  filter(!(SID %in% sub_round_index)) %>%
  filter(L.self < R.self) %>%
  group_by(SID, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(p_left = Left/49) %>%
  mutate(p_right = Right/49) %>%
  select(-`vars(side_chosen)`) %>%
  mutate(prob_type = "Right")
  
probRight <- rbind(probRight4, probRight8)

probs <- rbind(probEqual, probLeft, probRight)

left.balProb <- respData %>%
  mutate(self_diff = L.self - R.self) %>%
  group_by(self_diff, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(total = Left + Right) %>%
  mutate(p_left = Left/total) %>%
  mutate(p_right = Right/total) %>%
  select(-`vars(side_chosen)`)

left.balProbSubs <- respData %>%
  mutate(self_diff = L.self - R.self) %>%
  group_by(self_diff, SID, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(Right = replace(Right, is.na(Right), 0)) %>%
  mutate(Left = replace(Left, is.na(Left), 0)) %>%
  mutate(total = Left + Right) %>%
  mutate(p_left = Left/total) %>%
  mutate(p_right = Right/total) %>%
  select(-`vars(side_chosen)`)

respDataLong <- respData %>%
  group_by(slope) %>%
  mutate(other_payout_total = sum(other.payoff)) %>%
  group_by(SID, slope) %>%
  mutate(other_payout_total_by_subs = sum(other.payoff))




```

```{r prep-real-slope, eval = T}

realSlopePrep <- respData %>%
  mutate(self_diff = L.self - R.self) %>%
  mutate(other_diff = L.other - R.other) %>%
  mutate(ratio = if_else(self_diff == 0 | other_diff == 0 , 999, # hold the place for the logic, will be changed later
                         if_else(self_diff %% other_diff == 0, self_diff/other_diff, 
                         if_else(other_diff %% other_diff == 0, other_diff/self_diff, 999)))) %>%
  mutate(ratio_dir = if_else(self_diff == other_diff, "1:1", 
                             if_else(self_diff == 0 | other_diff == 0, paste0(self_diff, ":", other_diff),
                             if_else(ratio == -1 & self_diff > other_diff, "1:-1", 
                             if_else(ratio == -1 & other_diff > self_diff, "-1:1", 
                             if_else(self_diff %% other_diff == 0, ":1", 
                             if_else(other_diff %% self_diff == 0, "1:", 
                                     paste0(self_diff, ":", other_diff)))))))) # if nothing is divisible, paste direct values

realSlope1 <- realSlopePrep %>%
  filter(ratio_dir == ":1") %>%
  mutate(ratio_dir = paste0(ratio, ratio_dir))

realSlope2 <- realSlopePrep %>%
  filter(ratio_dir == "1:") %>%
  mutate(ratio_dir = paste0(ratio_dir, ratio))

realSlope3 <- realSlopePrep %>%
  filter(ratio_dir != ":1" & ratio_dir != "1:")


realSlopeFull <- rbind(realSlope1, realSlope2, realSlope3)
  
realSlope <- realSlopeFull %>%  
  group_by(ratio_dir, SID, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(Right = replace(Right, is.na(Right), 0)) %>%
  mutate(Left = replace(Left, is.na(Left), 0)) %>%
  mutate(total = sum(Left + Right, `<NA>`, na.rm = T)) %>%
  mutate(p_left = Left/total) %>%
  mutate(p_right = Right/total) %>%
  select(-`vars(side_chosen)`)

```


```{r prep-ref-ten, eval = F}


refTenPrep <- respData %>%
  mutate(L_self_norm = L.self - 10) %>%
  mutate(R_self_norm = R.self - 10) %>%
  mutate(L_other_norm = L.other - 10) %>%
  mutate(R_other_norm = R.other - 10) %>%  
  mutate(self_diff = if_else(L_self_norm == 0, R_self_norm, L_self_norm)) %>%
  mutate(other_diff = if_else(L_other_norm == 0, R_other_norm, L_other_norm)) %>%
  mutate(ratio = if_else(self_diff == 0 | other_diff == 0 , 999, # hold the place for the logic, will be changed later
                         if_else(self_diff %% other_diff == 0, self_diff/other_diff, 
                         if_else(other_diff %% other_diff == 0, other_diff/self_diff, 999)))) %>%
  mutate(ratio_dir = if_else(self_diff == other_diff, "1:1", 
                             if_else(self_diff == 0 | other_diff == 0, paste0(self_diff, ":", other_diff),
                             if_else(ratio == -1 & self_diff > other_diff, "1:-1", 
                             if_else(ratio == -1 & other_diff > self_diff, "-1:1", 
                             if_else(self_diff %% other_diff == 0, ":1", 
                             if_else(other_diff %% self_diff == 0, "1:", 
                                     paste0(self_diff, ":", other_diff)))))))) # if nothing is divisible, paste direct values

refTen1 <- refTenPrep %>%
  filter(ratio_dir == ":1") %>%
  mutate(ratio_dir = paste0(ratio, ratio_dir))

refTen3 <- refTenPrep %>%
  filter(ratio_dir == "1:") %>%
  mutate(ratio_dir = paste0(ratio_dir, ratio))

refTen3 <- refTenPrep %>%
  filter(ratio_dir != ":1" & ratio_dir != "1:")


refTenFull <- rbind(refTen1, refTen1, refTen1)
  
refTen <- refTenFull %>%  
  group_by(ratio_dir, SID, side_chosen) %>%
  summarise(vars(side_chosen), n()) %>%
  spread(key = side_chosen, value = `n()`) %>%
  mutate(Right = replace(Right, is.na(Right), 0)) %>%
  mutate(Left = replace(Left, is.na(Left), 0)) %>%
  mutate(total = sum(Left + Right, `<NA>`, na.rm = T)) %>%
  mutate(p_left = Left/total) %>%
  mutate(p_right = Right/total) %>%
  select(-`vars(side_chosen)`)

```

```{r regression-df}
lmData <- respDataRaw %>%
  mutate(side_chosen_numeric = side.chosen) %>%
  mutate(side_chosen = if_else(side.chosen == 76, "Left", if_else(side.chosen == 82, "Right", "Other"))) %>%
  mutate(side_chosen = factor(side_chosen))

```
# Task Structure 

In looking through the task code, I was able to see that the order and the sets (ie `Left_self 12`, `Left_other 12`, `Right_self 10`, `Right_other 10`) were all controlled by the csv `payoffs_active3.csv`, and the order and set types was fixed among all subjects (no counterbalancing). 

I first tried plotting the number of trial types, where the type of trial is defined by the difference in how much you could win by the difference in how much the other could win. I subtract Left side from the Right side, so large positive numbers mean both that there is a large difference in payout and the better option is on the left, while large negative numbers mean there is a large difference in payout, but the better option is on the right.


```{r wrong-task-structure}

respDataRaw %>%
  mutate(self_diff = L.self - R.self) %>%
  mutate(other_diff = L.other - R.other) %>%
  ggplot(., aes(x = factor(self_diff), y = factor(other_diff))) +
  geom_bin2d() + 
  labs(y = "Difference in Payout to Other", x = "Difference in Payout to Self")  +
  theme(panel.background = element_rect(fill = "white", color = "black"))

```


The color represents the number of trials. And from the lack of symmetry whatsoever I figured I have the wrong way of thinking about trials. So I tried looking at ratios instead. I again calculated the difference in payout for the self and for the other, but characterized each trial as a ratio between these numbers. Below, I group all these trial types on the x axis, and on the y the number of such trials. Again, the negative vs positive tells us which side was better, so `20:0`, means the difference for the self between left and right options was 20, there were no differences for the other subject, and that the better option for self payout was on the left.

```{r correct-trial-structure}

newTrial <- realSlope %>%
  filter(SID == "DG_s08") %>%
  ggplot(., aes(x = factor(ratio_dir), y = total, fill = factor(ratio_dir))) +
  geom_col(position = "dodge") +
  theme(panel.background = element_rect(fill = "white", color = "black")) +
  labs(x = "", fill = "Ratio") +
  scale_y_continuous(breaks = c(3, 6, 18, 24, 36, 60)) +
  scale_fill_manual(values = getPalette(23)) 

oldTrial <- realSlope %>%
  filter(SID == "DG_s01") %>%
  ggplot(., aes(x = factor(ratio_dir), y = total, fill = factor(ratio_dir))) +
  geom_col(position = "dodge") +
  theme(panel.background = element_rect(fill = "white", color = "black")) +
  labs(x = "", fill = "Ratio") +
  scale_y_continuous(breaks = c(3, 6, 18, 24, 36, 60)) +
  scale_fill_manual(values = getPalette(23)) 


realSlopeFull_check <- realSlopeFull %>%
  filter(SID == "DG_s08") %>%
  select(round, ratio_dir)

# should be all zeros
print(paste0("the following should be a list of zeros: ", sum(sort(realSlopeFull_check$round) - 1:228)))

plot(arrangeGrob(grobs = list(ggplotGrob(newTrial),ggplotGrob(oldTrial)), nrow = 2, ncol = 1))


```

_the following are notes of me trying to figure out a pattern via slopes, without much luck_

So there are 12 of each trial type, which seems human designed. BUT the earlier plot from html printed on December 6th was buggy and capturing the number of subjects not the number of trials. By happenstance `12 * 19 = 228` and we have 12 subjects, so it passed my quick sanity check. The real plot of the number of trials by slope is all over the place. below are table of me trying to figure it out.

       3 6 18 24 36 60
       
  Disadventageous Ineq.
  0:12 2 0  0  0  0  0
  0:16 0 1  0  0  0  0
  0:20 0 1  0  0  0  0
  0:8  0 1  0  0  0  0
  Total = 24
  
  Adventageous Ineq.
  8:0  0 1  0  0  0  0  
  20:0 2 0  0  0  0  0
  12:0 2 0  0  0  0  0
  16:0 2 0  0  0  0  0  
  Total = 24
  
  
  2:1  0 1  0  0  0  0
  3:1  0 0  1  0  0  0
  4:1  0 1  0  1  0  0
  7:2  2 0  0  0  0  0
  Total = 60
  
  1:3  0 0  0  0  1  0
  1:4  0 0  0  1  0  0 
  Total = 60
  
  We both win
  1:1  0 0  0  0  0  1 
  Toal = 60  



I thought that maybe the structure was in relationship to 10. So the slope piece might be right, but first you have to subract 10 to better reveal which trials were "losing" trials for the self or for the other. Stopped this investigation after seeing that the best groupings seem to be the raw values.
```{r ref-ten-trial-structure, eval = F}

noside_refTen <- refTen %>%
  filter(SID == "DG_s08")


newTrialRefTen <- refTen %>%
  filter(SID == "DG_s08") %>%
  ggplot(., aes(x = factor(ratio_dir), y = total, fill = factor(ratio_dir))) +
  geom_col(position = "dodge") +
  theme(panel.background = element_rect(fill = "white", color = "black")) +
  labs(x = "", fill = "Ratio") +
  scale_y_continuous(breaks = c(3, 6, 18, 24, 36, 60)) +
  scale_fill_manual(values = getPalette(23)) 

oldTrialRefTen <- refTen %>%
  filter(SID == "DG_s01") %>%
  ggplot(., aes(x = factor(ratio_dir), y = total, fill = factor(ratio_dir))) +
  geom_col(position = "dodge") +
  theme(panel.background = element_rect(fill = "white", color = "black")) +
  labs(x = "", fill = "Ratio") +
  scale_y_continuous(breaks = c(3, 6, 18, 24, 36, 60)) +
  scale_fill_manual(values = getPalette(23)) 


table(noside_refTen$ratio_dir, noside_refTen$total)

refTenFull_check <- refTenFull %>%
  filter(SID == "DG_s08") %>%
  select(round, ratio_dir)

# should be all zeros
sort(refTenFull_check$round) - 1:228

plot(arrangeGrob(grobs = list(ggplotGrob(newTrial),ggplotGrob(oldTrial)), nrow = 2, ncol = 1))


```


# Left Bias

```{r sanity-checks-1}

## self diff and other diff are not correlated ##
# respData %>%
#   filter(SID == "DG_s01") %>%
#   ggplot(., aes(x = self_diff, y = other_diff)) + 
#   geom_point(alpha = .1, size = 3) +
#   theme(panel.background = element_rect(fill = "white"))

## plot 10-10 choice vs anything else##
# respData %>%
#   ggplot(., aes(x = option_one, fill = option_one)) +
#   geom_bar() +
#   theme(panel.background = element_rect(fill = "white")) + 
#   facet_wrap(~SID)

## side chosen proportions ##
respData %>%
  ggplot(., aes(x = side_chosen, fill = side_chosen)) +
  geom_bar() +
  theme(panel.background = element_rect(fill = "white")) + 
  facet_wrap(~SID)

```

This plot shows the proportion of times the Left vs Right option was selected by the participants. On average it seems they pick the left 2:1 times more than the right, with the exception of `DG_s05` who actually always picks the 10-10 option. The following analyses explore why, were subjects just pressing left because they were not paying attention, or were they pressing left because it was more rational to do so? 


```{r}
## payout on left differences ##
# respData %>%
#   filter(SID == "DG_s01") %>%
#   group_by(side_chosen) %>%
#   mutate(self.payoff.average = mean(self.payoff)) %>%
#   ggplot(., aes(x= side_chosen, y = self.payoff.average, fill = self.payoff.average)) +
#   geom_col() +
#   theme(panel.background = element_rect(fill = "white"))

## payout on left differences ##
# respData %>%
#   filter(SID == "DG_s01") %>%
#   ggplot(., aes(x = self.payoff, color = side_chosen, fill = side_chosen)) +
#   geom_density(alpha = .5) +
#   theme(panel.background = element_rect(fill = "white"))


# respData %>%
#   filter(SID == "DG_s01") %>%
#   gather(key = "Side", value = "PayoutSelf", L.self, R.self) %>%
#   ggplot(., aes(x = PayoutSelf, color = Side, fill = Side)) +
#   geom_histogram(alpha = .5) +
#   theme(panel.background = element_rect(fill = "white"))

## Probs of picking left when it is equal, left better or right better ##
# probs %>%
#   gather(key = "Side", value = "Probability", p_left, p_right) %>%
#   ggplot(., aes(x = Side, y = Probability, fill = SID)) + 
#   geom_col(position = "dodge") +
#   theme(panel.background = element_rect(fill = "white")) +
#   scale_fill_manual(values = getPalette(12)) +
#   facet_wrap(~prob_type)

## orignal attempt at Deborah's idea of symmetry around P(Left when diff =0)  ##
# left.balProb %>%
#   ggplot(., aes(x = factor(self_diff), y = p_left, fill = factor(self_diff))) +
#   geom_col(position = "dodge") +
#   theme(panel.background = element_rect(fill = "white")) +
#   scale_fill_manual(values = getPalette(21)) 

# left.balProbSubs %>%
#   ggplot(., aes(x = factor(self_diff), y = p_left, fill = factor(self_diff))) +
#   geom_col(position = "dodge") +
#   theme(panel.background = element_rect(fill = "white", color = "black")) +
#   scale_fill_manual(values = getPalette(21)) +
#   facet_wrap(~SID)

```

So this plot shows the trial design data (nothing to do with subject responses). On the x axis there is the difference in self payout, and the color shows how often that amount was on the left versus the right. Left was more likely to have higher payouts, and right was more likely to have worse payouts.

```{r}

ggthemr("solarized")
self_dots <- lmData %>%
  filter(SID == "DG_s05") %>%
  gather(key = "Side", value = "Value", L.self, R.self) %>%
  ggplot(., aes(x = round, y = Value, color = Side)) +
  geom_point() +
  geom_line() + 
  theme(panel.background = element_rect(fill = "white"))



other_dots <- lmData %>%
  filter(SID == "DG_s05") %>%
  gather(key = "Side", value = "Value", L.other, R.other) %>%
  ggplot(., aes(x = round, y = Value, color = Side)) +
  geom_point() +
  geom_line() + 
  theme(panel.background = element_rect(fill = "white"))

plot(arrangeGrob(grobs = list(ggplotGrob(self_dots),ggplotGrob(other_dots)), nrow = 2, ncol = 1))
```


Here is the same thing shown over time in the task. Right is often worse and left is often better (for self payout). At this point we wanted to run some regressions just as a sanity check that each component mattered to subject choice. So we ran logistic mixed effects models, where the fixed effects vars were `Left_Self` `Left_Other` `Right_self` `Right_other` and had a random effect of subject. Each variable significantly contributed to the model, and 95% confidence intervals around the betas did not include 1 for any variable (when converted to log odds ratio)

chosen_self

chosen_other

advantageous equity

disadventageous equity



```{r trial-distributions}
 # ggthemr("solarized")

# ineqData <- respData %>%
#   filter(better_other != better_self)
# 
# ineqData %>%
#   ggplot(., aes(x= ethical, fill = ethical)) +
#   geom_bar() +
#   theme(panel.background = element_rect(fill = "white")) +
#   facet_wrap(~slope, ncol = 4)
# 
# ggthemr_reset()
# ineqData %>%
#   ggplot(., aes(x= ethical, fill = SID)) +
#   geom_bar(color = "black") +
#   theme(panel.background = element_rect(fill = "white")) +
#   facet_wrap(~slope, ncol = 4)
# 
# payoffData %>%
#   ggplot(., aes(x= factor(slope), y = other_payout_total, fill = factor(slope))) +
#   geom_col() +
#   theme(panel.background = element_rect(fill = "white"))
# 

ggthemr("solarized")
newTrials <- respData %>%
  filter(round > 200) %>%
  ggplot(., aes(x = slope)) +
  geom_histogram() +
  theme(panel.background = element_rect(fill = "white")) +
  ggtitle("Last 28 Trials")

oldTrials <- respData %>%
  filter(round < 201) %>%
  ggplot(., aes(x = slope)) +
  geom_histogram() +
  theme(panel.background = element_rect(fill = "white")) +
  ggtitle("First 200 Trials")

plot(arrangeGrob(grobs = list(ggplotGrob(newTrials),ggplotGrob(oldTrials)), nrow = 1, ncol = 2))

# table(respData$selfish)

```


```{r regressions}

## run regressions on the resp data with only side chosen edited, since it is in the correct form, smaller chance of bugs ##

## right side ##
# 
# # right self #
# right.self.lm <- glmer(side_chosen ~ R.self + (1|SID), data = lmData, family = binomial)
# summary(right.self.lm)
# 
# se <- sqrt(diag(vcov(right.self.lm)))
# # table of estimates with 95% CI
# exp(tab <- cbind(Est = fixef(right.self.lm), LL = fixef(right.self.lm) - 1.96 * se, UL = fixef(right.self.lm) + 1.96 *
#     se))
# 
# # right other #
# right.other.lm <- glmer(side_chosen ~ R.other + (1|SID), data = lmData, family = binomial)
# summary(right.other.lm)
# 
# se <- sqrt(diag(vcov(right.other.lm)))
# # table of estimates with 95% CI
# exp(tab <- cbind(Est = fixef(right.other.lm), LL = fixef(right.other.lm) - 1.96 * se, UL = fixef(right.other.lm) + 1.96 *
#     se))
# 
# # right combined #
# right.lm <- glmer(side_chosen ~ R.self + R.other + (1|SID), data = lmData, family = binomial)
# summary(right.lm)
# 
# se <- sqrt(diag(vcov(right.lm)))
# # table of estimates with 95% CI
# exp(tab <- cbind(Est = fixef(right.lm), LL = fixef(right.lm) - 1.96 * se, UL = fixef(right.lm) + 1.96 *
#     se))
# 
# ## left side ##
# 
# # left self #
# left.self.lm <- glmer(side_chosen ~ L.self + (1|SID), data = lmData, family = binomial)
# summary(left.self.lm)
# 
# se <- sqrt(diag(vcov(left.self.lm)))
# # table of estimates with 95% CI
# exp(tab <- cbind(Est = fixef(left.self.lm), LL = fixef(left.self.lm) - 1.96 * se, UL = fixef(left.self.lm) + 1.96 *
#     se))
# 
# # left other #
# left.other.lm <- glmer(side_chosen ~ L.other + (1|SID), data = lmData, family = binomial)
# summary(left.other.lm)
# 
# se <- sqrt(diag(vcov(left.other.lm)))
# # table of estimates with 95% CI
# exp(tab <- cbind(Est = fixef(left.other.lm), LL = fixef(left.other.lm) - 1.96 * se, UL = fixef(left.other.lm) + 1.96 *
#     se))
# 
# # left combined #
# left.lm <- glmer(side_chosen ~ L.self + L.other + (1|SID), data = lmData, family = binomial)
# summary(left.lm)
# 
# se <- sqrt(diag(vcov(left.lm)))
# # table of estimates with 95% CI
# exp(tab <- cbind(Est = fixef(left.lm), LL = fixef(left.lm) - 1.96 * se, UL = fixef(left.lm) + 1.96 *
#     se))

## combined ##

sides.lm  <- glmer(side_chosen ~ L.self + L.other + R.self + R.other + (1|SID), data = lmData, family = binomial)
summary(sides.lm)

se <- sqrt(diag(vcov(sides.lm)))
# table of estimates with 95% CI
exp(tab <- cbind(Est = fixef(sides.lm), LL = fixef(sides.lm) - 1.96 * se, UL = fixef(sides.lm) + 1.96 *
    se))



```



Finally, I looked at the left side bias only for trials that were actually counterbalanced. These are the `-12:0` and `12:0`, `-16:0` and `16:0`, `-20:0` and `20:0`, and `-4:1` and `4:1`. If subjects are really paying attention and are not just absentmindedly pressing the left option, we should see that the probability of pressing left on the `-12:0` and `12:0` option should sum to 1. And we see that fore the majority of subjects. 


```{r}

realSlope %>%
  filter(ratio_dir %in% c("-12:0", "12:0", "-16:0", "16:0", "-20:0", "20:0", "-4:1", "4:1")) %>%
  ggplot(., aes(x = factor(ratio_dir), y = p_left, fill = factor(ratio_dir))) +
  geom_col(position = "dodge") +
  labs(x = "", fill = "Ratio") +
  theme(panel.background = element_rect(fill = "white", color = "black")) +
  scale_fill_manual(values = getPalette(21)) +
  facet_wrap(~SID)

```

Looking at subject `DG_s10`, we see that they selected left for trials `12:0`, `16:0`, `20:0` 100% of the time, and selected `-12:0`, `-16:0`, `-20:0` 0% of the time which is perfectly symmetric. For the `4:1` and `-4:1` trials they select left when the right side is better `45% of the time left when left is better ~60% of the time, which seems reasonable. Subjects 1, 3, 4, 6, 9, 10, 12 and probably 11 all follow this pattern.

Subject `DG_s02` is more worrying to me, because 100% of the time they selected left when the ratios were `12:0`, `16:0`, `20:0` , but 50-100% of the time they _also selected left_ when the ratios were `-12:0`, `-16:0`, `-20:0`. For this subject, it seems harder to say they were encoding the actual values of the options rather than just encoding left is better.

# create new counter balanced df

Trials were described by concactenating the options with `:` and counting the number of times those options appear. They appear either 3 or 6 times. In the new df we split all cases that 6 into 3 and 3 with counterbalancing. The majority of the 3 options were already counterbalanced, but the few that were not were counterbalanced using the following procedure.

Specifically trial types with only 3 cases were like `2:2:10:10` or `10:10:14:14`. For these I split them so that there was at least one of each type presented on each type, ie if there was `2:2:10:10` there was also at least one `10:10:2:2`. And for the remaining I split it such that sum over these trials was equal, eg `2:2:10:10` and `8:8:10:10` with `10:10:6:6` and 1`0:10:4:4`.


```{r raw_trial_structure}
## create dfs that will be used to create the new trials ##

# Use a single subject who was run on the 228 trial version #
sub8Structure <- respData %>%
  filter(SID == "DG_s08")

# get the list of trial types and turn into a df with counts #
trial_totals <- table(sub8Structure$trial_type_full)
trialTotals <- data.frame(trial_totals)
colnames(trialTotals) <- c("Type", "Count")

# create cols that describe where the 10:10 option was and what type the trial was excluding side #
trialTotals <- trialTotals %>%
  mutate(minus_ten = gsub(":10:10", "", Type)) %>%
  mutate(minus_ten = gsub("10:10:", "", minus_ten)) %>%
  mutate(ten_side = if_else(grepl("^10:10:", Type), "Left", "Right"))

# get a df with all the trial types that were only presented 3 times and count the number trial tyeps (not including side/10:10) #
threeTotals <- trialTotals %>%
  filter(Count == 3) %>%
  group_by(minus_ten) %>%
  mutate(count_minus_ten = n())


```



```{r create-new-df}
## crea the new trial df that can be used to run the dictator game ##


# filter the 3-count trials that were already counter balanced for later #
threeKeepTotals <- threeTotals %>%
  filter(count_minus_ten == 2) 

# filter the ones that were not counterbalanced and create cb versions of the trials #
threeModify <- threeTotals %>%
  filter(count_minus_ten == 1) %>%
  mutate(new_type = if_else(ten_side == "Left", paste0(minus_ten, ":10:10"), paste0("10:10:", minus_ten)))
  
# get the 6-count trials and create cb versions #
sixTotals <- trialTotals %>%
  filter(Count == 6) %>%
  mutate(new_type = if_else(ten_side == "Left", paste0(minus_ten, ":10:10"), paste0("10:10:", minus_ten))) 

# create a df with all trials that will be presented 3 times in the new version #
new_trialStruct <- data.frame("Type" = c(as.character(threeKeepTotals$Type), as.character(sixTotals$Type), as.character(sixTotals$new_type)), Count = 3)

# create a df with all the trials that will be presented 1 or 2 times in the new version#
new_trialTemp <- data.frame("Type" = c(as.character(threeModify$Type), as.character(threeModify$new_type)), Count = 1)

# manually set the trials that will be presented twice to 2 #
new_trialTemp <- new_trialTemp %>%
  mutate(Count = if_else(Type %in% c("10:10:8:8", "10:10:2:2", "10:10:12:12", "10:10:18:18"), 2, 
                         if_else(Type %in% c("6:6:10:10", "4:4:10:10", "14:14:10:10", "16:16:10:10"), 2, 1)))

# bind the two dfs together #
new_trialStruct <- rbind(new_trialStruct, new_trialTemp)

# create a vec of all the trial types where the type appears the appropriate num of tiimes #
pool_of_trial_typs <- c()
for(row in 1:nrow(new_trialStruct)){
  pool_of_trial_typs <- c(pool_of_trial_typs, rep(as.character(new_trialStruct$Type)[row], new_trialStruct$Count[row]))
}

# set seed and randomize #
set.seed(42)
final_order <- data.frame("Type" = sample(pool_of_trial_typs, 228, replace = F))

# organize into a format appropriate for the dictator task script #
final_new_trial_df <- final_order %>%
  separate(Type, into = c("L.self", "L.other", "R.self", "R.other"), sep = ":") %>%
  mutate(L.self = as.numeric(L.self)) %>%
  mutate(R.self = as.numeric(R.self)) %>%
  mutate(L.other = as.numeric(L.other)) %>%
  mutate(R.other = as.numeric(R.other)) %>%
  mutate(round = 1:228)


```



```{r check-new-df}

## some sanity checks to see if df was properly counterbalanced ##
ggthemr("solarized")
final_new_trial_df %>%
  gather(key = "Side", value = "Value", L.self, R.self) %>%
  ggplot(., aes(x = round, y = Value, color = Side)) +
  geom_point() +
  geom_line() + 
  theme(panel.background = element_rect(fill = "white"))

final_new_trial_df %>%
  gather(key = "Side", value = "Value", L.other, R.other) %>%
  ggplot(., aes(x = round, y = Value, color = Side)) +
  geom_point() +
  geom_line() + 
  theme(panel.background = element_rect(fill = "white"))


final_new_trial_df %>%
  mutate(ten_side = if_else(L.self == 10 & L.other == 10, "Left", "Right")) %>%
  ggplot(., aes(x = ten_side)) +
  geom_bar() +
  theme(panel.background = element_rect(fill = "white"))

print(paste0("The differences in sums between the left and right self payouts is: ", sum(final_new_trial_df$L.self) - sum(final_new_trial_df$R.self)))

print(paste0("The differences in sums between the left and right other payouts is: ", sum(final_new_trial_df$L.other) - sum(final_new_trial_df$R.other)))

# follow colnames for dictator task script #
colnames(final_new_trial_df)[5] <- "X"

# write the csv #
write.csv(final_new_trial_df, "./new_trials_counterbalanced.csv", row.names = F)

```

# check modifications from Deborah

```{r check-deb-df}

## some sanity checks to see if df was properly counterbalanced ##
ggthemr("solarized")

# read in data #
debTrials <- read.csv('~/Downloads/new_trials_counterbalanced2.csv', header = T)

debTest <- debTrials %>%
    mutate(trial_type_full = paste0(L.self, ":", L.other, ":",  R.self, ":", R.other))

trial_totals <- table(debTest$trial_type_full)
trialTotals <- data.frame(trial_totals)
colnames(trialTotals) <- c("Type", "Count")

# create cols that describe where the 10:10 option was and what type the trial was excluding side #
trialTotals <- trialTotals %>%
  mutate(minus_ten = gsub(":10:10", "", Type)) %>%
  mutate(minus_ten = gsub("10:10:", "", minus_ten)) %>%
  mutate(ten_side = if_else(grepl("^10:10:", Type), "Left", "Right"))

debTrials %>%
  gather(key = "Side", value = "Value", L.self, R.self) %>%
  ggplot(., aes(x = X, y = Value, color = Side)) +
  geom_point() +
  geom_line() + 
  theme(panel.background = element_rect(fill = "white"))

debTrials %>%
  gather(key = "Side", value = "Value", L.other, R.other) %>%
  ggplot(., aes(x = X, y = Value, color = Side)) +
  geom_point() +
  geom_line() + 
  theme(panel.background = element_rect(fill = "white"))


debTrials %>%
  mutate(ten_side = if_else(L.self == 10 & L.other == 10, "Left", "Right")) %>%
  ggplot(., aes(x = ten_side)) +
  geom_bar() +
  theme(panel.background = element_rect(fill = "white"))

print(paste0("The differences in sums between the left and right self payouts is: ", sum(debTrials$L.self) - sum(debTrials$R.self)))

print(paste0("The differences in sums between the left and right other payouts is: ", sum(debTrials$L.other) - sum(debTrials$R.other)))

## needs computer choice ##

older_version <- read.csv('../../../Dictator Game v1.4/data/payoffs_active_3.csv', header = T)

final_version <- cbind(debTrials, older_version$ComputerChoice)

colnames(final_version)[6] <- "ComputerChoice"

write.csv(final_version, 'final_counterbalanced_trial_file.csv', row.names = F)



```